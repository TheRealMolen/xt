
;; cut down version of analogue synth that runs on a little pc

;; osc1 is sine
;; osc2 is saw
;; osc3 is pulse
;; osc4 is white noise



;; NOTE
(bind-func analogue_note
  (lambda ()
    (let ((MILLISEC (* .001 SRs))
          (amp_env:|4,SAMPLE| (array 0.0:f 0.0 1.0 0.0))
          (filter_env:|4,SAMPLE| (array 0.0:f 0.0 1.0 0.0))
          (pitch_env:|2,SAMPLE| (array 0.0:f 0.0))
          (mod_env:|4,SAMPLE| (array 0.0:f 0.0 1.0 0.0))
          (oldfreq 440.0:f)
          (tune1:SAMPLE 1.0)
          (tune2:SAMPLE 1.0)
          (tune3:SAMPLE 1.0)
          (tune4:SAMPLE 1.0)
          (osc1_wave:enum PARAM_SAW)
          (osc2_wave:enum PARAM_SAW)
          (osc3_wave:enum PARAM_SAW)
          (osc4_wave:enum PARAM_SAW)
          (pw1:SAMPLE 0.5)
          (pw2:SAMPLE 0.5)        
          (pw3:SAMPLE 0.5)                  
          (pw4:SAMPLE 0.5)                  
          (noise:enum PARAM_WHITE) ;; white
          (noise_amp:SAMPLE 0.0)
          (osc1_amp:SAMPLE 0.4)
          (osc2_amp:SAMPLE 0.0)
          (osc3_amp:SAMPLE 0.0)
          (osc4_amp:SAMPLE 0.0)
          (osc1_pan:SAMPLE 0.5)
          (osc2_pan:SAMPLE 0.5)
          (osc3_pan:SAMPLE 0.5)
          (osc4_pan:SAMPLE 0.5)
          (sub_pan:SAMPLE 0.5)
          (noise_pan:SAMPLE 0.5)
          (sub_amp:SAMPLE 0.0) 
          (mods:|32,SAMPLE|* (alloc))
          (noise_amp_mod:SAMPLE 0.0)
          (filter_type:i64 2) ;; LPF2 LPF4, HPF2 HPF4, BPF2 BPF4
          (follow_frq 0.0)
          (follow_amp 0.0)
          (legato #f) ;; if legato is true then don't retrigger adsr's!
          (filter_frq:SAMPLE 15000.0) ;; 
          (filter_env_amt:SAMPLE 0.0) ;; this for lpf
          (filter_saturation:SAMPLE 1.0)
          (pitch_env_amt:SAMPLE 0.0)
          (portamento:SAMPLE 2.0) ;; in millis
          (res:SAMPLE 0.0)
          (reso:SAMPLE 0.0))
      (lambda (data:NoteData* nargs:i64 dargs:SAMPLE*)
        ;; (println "NEW NOTE!" data)
        (let ((starttime:i64 (note_starttime data))
              (frequency:SAMPLE (note_frequency data))
              (target_frq:SAMPLE frequency)
              (amplitude:SAMPLE (note_amplitude data))
              (target_amp:SAMPLE amplitude)
              (newampinc:SAMPLE 0.0)
              (duration:i64 (note_duration data))
              (glideinc:SAMPLE 0.0) ;; for portamento
              (midifrq:SAMPLE 0.0)
              (new_note_timer:i64 0)
              (frq 0.0)
              (adsr1 (adsr_c))
              (adsr2 (adsr_c))
              (adsr3 (adsr_c))
              (adsr4 (adsr_c))
              (adsr1_val 0.0)
              (adsr2_val 0.0)
              (adsr3_val 0.0)
              (adsr4_val 0.0)
              (amp:SAMPLE 0.0)
              (cof:SAMPLE 0.0)
              (amp_attack (aref amp_env 0))
              (amp_decay (aref amp_env 1))
              (amp_sustain (aref amp_env 2))
              (amp_release (+ 3.0 (aref amp_env 3))) ;; a 3ms release minimum 
              (amp_release_samples (convert (* SRs (/ amp_release 1000.0)) i64))
              (reltime:i64 0)
              (filter_attack (aref filter_env 0))
              (filter_decay (aref filter_env 1))
              (filter_sustain (aref filter_env 2))
              (filter_release (aref filter_env 3))
              (pitch_attack (aref pitch_env 0))
              (pitch_decay (aref pitch_env 1))
              (mod_attack (aref mod_env 0))
              (mod_decay (aref mod_env 1))
              (mod_sustain (aref mod_env 2))
              (mod_release (aref mod_env 3))
              (filter (moog_ladder (i64toi32 filter_type)))
              (filterR (moog_ladder (i64toi32 filter_type)))
              (sin1 (osc_c (* .025 (random))))
              (saw2 (blsaw_c (* .025 (random)) #f #f))
              (pulse3 (blpulse_c 1.0 #f))
              (tri4 (bltri_c 1.0))
              (white (white_c))
              (osc1_out 0.0)
              (osc2_out 0.0)
              (osc3_out 0.0)
              (osc4_out 0.0)
              (zero:SAMPLE 0.0)
              (sub_out 0.0)
              (noise_out 0.0)
              (subosc (osc_c 0.0))              
              (main_out 0.0:f))
          (filter.saturation (clamp filter_saturation 1.0:f 3.0:f))
          (filterR.saturation (clamp filter_saturation 1.0:f 3.0:f))
          (lambda (time:i64 chan:i64)
            (if (= chan 0) 
                (begin
                  (if (and (> (note_gate data) 0.5) (> (- time starttime) duration)) (note_gate data 0.0)) ;; (set! gate 0.0))
                  (set! adsr1_val (adsr1 chan (note_gate data) amp_attack amp_decay amp_sustain amp_release))
                  (set! adsr2_val (adsr2 chan (note_gate data) filter_attack filter_decay filter_sustain filter_release))
                  (set! adsr3_val (adsr3 chan (note_gate data) pitch_attack pitch_decay 0.0 0.0))
                  (set! adsr4_val (adsr4 chan (note_gate data) mod_attack mod_decay mod_sustain mod_release))
                  (set! amp (* amplitude adsr1_val))
                  (set! cof (clamp (+ filter_frq (* follow_frq frequency) (* follow_amp amplitude)
                                      (* adsr4_val (aref mods PARAM_FILTER_FRQ))
                                      (* filter_env_amt adsr2_val))
                                   0.0 22000.0))
                  (set! res (+ reso (* adsr4_val (aref mods PARAM_FILTER_RES))))
                  (set! frq (+ frequency (* pitch_env_amt frequency adsr3_val) 0.0))
                  (if (< frq 10.0) (set! frq 10.0))
                  ;; if gate is OFF and amp is sufficiently close to 0.0 then stop note!
                  (if (< (note_gate data) 0.1) (set! reltime (+ reltime 1)))
                  (if (> reltime amp_release_samples)
                      (begin
                        ;; (println "NOTE OFF!" data)
                        (note_active data #f)))
                  ;; (if (and (< gate 0.5) (< amp 0.00001)) (note_active data #f))
                  ;; setup mod sources
                  (if (> osc1_amp 0.001)
                      (set! osc1_out (* (+ osc1_amp (* adsr4_val (aref mods PARAM_OSC1_AMP)))
                                        (sin1 1.0 (+ (* tune1 frq) (* adsr4_val (aref mods PARAM_OSC1_FRQ))))))
                      (set! osc1_out 0.0))
                  (if (> osc2_amp 0.001)
                      (set! osc2_out (* (+ osc2_amp (* adsr4_val (aref mods PARAM_OSC2_AMP)))
                                        (saw2 1.0 (+ (* tune2 frq) (* adsr4_val (aref mods PARAM_OSC2_FRQ))))))
                      (set! osc2_out 0.0))
                  (if (> osc3_amp 0.001)
                      (set! osc3_out (* (+ osc3_amp (* adsr4_val (aref mods PARAM_OSC3_AMP)))
                                        (pulse3 1.0 (+ (* tune3 frq) (* adsr4_val (aref mods PARAM_OSC3_FRQ)))
                                                                       (+ pw3 (* adsr4_val (aref mods PARAM_OSC3_PW))))))
                                              ((= osc3_wave 3) (tri3 1.0 (+ (* tune3 frq) (* adsr4_val (aref mods PARAM_OSC3_FRQ)))))
                                              (else zero))))
                      (set! osc3_out 0.0))
                  (if (> osc4_amp 0.001)
                      (set! osc4_out (* (+ osc4_amp (* adsr4_val (aref mods PARAM_OSC4_AMP)))
                                        (tri4 1.0 (+ (* tune4 frq) (* adsr4_val (aref mods PARAM_OSC4_FRQ))))))
                      (set! osc4_out 0.0))
                  (if (> sub_amp 0.001)
                      (set! sub_out (* sub_amp (subosc 1.0 (* frq 0.25))))
                      (set! sub_out 0.0))
                  (if (> noise_amp 0.001)
                      (set! noise_out (* 0.5 (+ noise_amp (* adsr4_val (aref mods PARAM_NOISE_AMP))) (white)))
                      (set! noise_out 0.0))))
            (if (= chan 0)
                (* amp (filter (+ (* osc1_out osc1_pan)
                                  (* osc2_out osc2_pan)
                                  (* osc3_out osc3_pan)
                                  (* osc4_out osc4_pan)
                                  (* sub_out sub_pan)
                                  (* noise_out noise_pan))
                        cof reso))
                (if (= chan 1)
                    (* amp (filterR (+ (* osc1_out (- 1.0 osc1_pan))
                                        (* osc2_out (- 1.0 osc2_pan))
                                        (* osc3_out (- 1.0 osc3_pan))
                                        (* osc4_out (- 1.0 osc4_pan))
                                        (* sub_out (- 1.0 sub_pan))
                                        (* noise_out (- 1.0 noise_pan)))
                              cof reso))
                    0.0:f))))))))


;; FX
(bind-func analogue_fx
  (let ((MILLISEC (* .001 SRf))
        (CHANSF (i32tof CHANNELS)))
    (lambda ()
      (let ((notekernel:NOTE_KERNEL null)            
            (mod_amp:|4,SAMPLE|* (array_ref 1.0 1.0 1.0 1.0))
            (mod_frq:|4,SAMPLE|* (array_ref 1.0 1.0 1.0 1.0))
            (mod_attack:|4,SAMPLE|* (array_ref 10.0 10.0 10.0 10.0)) ;; in millis
            (mod_decay:|4,SAMPLE|* (array_ref 10.0 10.0 10.0 10.0))
            (mod_attack_slope:|4,SAMPLE|* (array_ref 0.0 0.0 0.0 0.0)) ;; between -1.0 log and 1.0 exp  (0.0 is linear)
            (mod_decay_slope:|4,SAMPLE|* (array_ref 0.0 0.0 0.0 0.0))
            (mods:|32,SAMPLE|* null) ;(alloc))
            (mod_matrix:|4,|32,SAMPLE||* (alloc))
            (tmpmod:|32,SAMPLE|* null)
            (lfos:|4,|6,[SAMPLE,i64,i64]*||* (alloc))
            (lfo_types:|4,i32|* (alloc))
            (hpf (hpf_c))
            (hpfR (hpf_c))
            (hpf_frq 20001.0)
            (dly (comb_lpf_mc_c (i32toi64 CHANNELS) (* SR 120))) ;; max 120 sec delay     
            (delay_time_left 50.0) ;; in ms
            (delay_time_right 50.0) ;; in ms
            (delay_in 1.0)
            (delay_mix 0.0)
            (delay_fb 0.5)
            (delay_frq 12000.0)
            (delay_res 0.0)
            (rev (reverb_st_c))
            (reverb_mix 0.0)
            (reverb_predelay 40.0) ;; in ms
            (reverb_size 0.3)
            (reverb_absorb 0.45)
            (pan (pan_c (i32toi64 CHANNELS)))
            (pan_pos 0.5)          
            (pan_width 1.0)
            (flanger (flanger_st_c))
            (flanger_low 0.1)
            (flanger_high 15.0)
            (flanger_rate 1.0)
            (flanger_fb 0.0)
            (flanger_mix 0.0)
            (overdrive (overdrive_c))
            (overdrive_amt 0.5) ;; always use some overdrive
            (out:SAMPLE 0.0)
            (i:i64 0) (j:i64 0)
            (tmp 0.0)
            (fxout 0.0)
            (gain 2.0))
        (dotimes (i 4)
          (aset! lfo_types i PARAM_SINE)
          (aset! lfos i
                 (array (let ((osc (osc_c 0.0)))
                          (lambda (chan:i64 idx:i64)
                            (osc (aref mod_amp idx)
                                 (aref mod_frq idx))))
                        (let ((osc (saw_c 0.0)))
                          (lambda (chan:i64 idx:i64)
                            (osc (aref mod_amp idx)
                                 (aref mod_frq idx))))
                        (let ((osc (pulse_c 0.0)))
                          (lambda (chan:i64 idx:i64)
                            (osc (aref mod_amp idx)
                                 (aref mod_frq idx)
                                 0.5)))
                        (let ((osc (tri_c 0.0)))
                          (lambda (chan:i64 idx:i64)
                            (osc (aref mod_amp idx)
                                 (aref mod_frq idx))))
                        (let ((osc (ad_c)))
                          (cset! osc cycle #t i1)
                          (lambda (chan:i64 idx:i64)
                            (osc chan 1.0
                                 (aref mod_attack idx)
                                 (aref mod_decay idx)
                                 (aref mod_attack_slope idx)
                                 (aref mod_decay_slope idx))))
                        (lambda (chan:i64 idx:i64) (aref mod_amp idx))))) ;; constant
        (lambda (in:SAMPLE time:i64 chan:i64 dat:SAMPLE*)
          ;; calc mod matrix changes
          (begin
            (if (= mods null) (set! mods (notekernel.mods:|32,SAMPLE|*)))
            (memset (cast mods i8*) 0 128) ;(size_of mods))
            (dotimes (i 4)
              (set! tmp ((aref (aref-ptr lfos i) (aref lfo_types i)) chan i))
              (set! tmpmod (aref-ptr mod_matrix i))
              (dotimes (j 32) (aset! mods j (+ (aref mods j) (* tmp (aref tmpmod j)))))
              void))
          ;; sound in for channel 1
          (if (= chan 0)
              (begin
                (set! out in)
                (set! out (overdrive out overdrive_amt))
                (if (< hpf_frq 20000.0)
                    (set! out (hpf out hpf_frq 0.0)))
                out))
          ;; sound in for channel 2
          (if (= chan 1)
              (begin
                (set! out in)
                (set! out (overdrive out overdrive_amt))
                (if (< hpf_frq 20000.0)
                    (set! out (hpfR out hpf_frq 0.0)))
                out))
          ;; apply FX to both channels 1 and 2
          (set! tmp (+ pan_pos (aref mods PARAM_PAN_POS)))
          (if (> tmp CHANSF) (set! tmp (- tmp CHANSF)))
          ;; always with the panning!
          (set! fxout (pan chan out
                           (+ pan_width (aref mods PARAM_PAN_WIDTH))
                           tmp))
          (if (> flanger_mix 0.001)
              (set! fxout (flanger chan fxout
                                   1.0 flanger_mix
                                   (* MILLISEC (+ flanger_low 0.0)) ;(aref mods PARAM_FLANGER_LOW)))
                                   (* MILLISEC (+ flanger_high 0.0)) ;(aref mods PARAM_FLANGER_HIGH)))
                                   (+ flanger_rate 0.0) ;(aref mods PARAM_FLANGER_RATE))
                                   (+ flanger_fb 0.0)))) ;;(aref mods PARAM_FLANGER_FB)))))
          (if (> delay_mix 0.001)
              (set! fxout (dly chan fxout
                               (if (= chan 0)
                                   (* MILLISEC (+ delay_time_left (aref mods PARAM_DELAY_TIME_LEFT)))
                                   (* MILLISEC (+ delay_time_right (aref mods PARAM_DELAY_TIME_RIGHT))))
                               delay_in
                               delay_mix
                               (+ delay_fb (aref mods PARAM_DELAY_FB))
                               delay_frq
                               delay_res)))
          (if (> reverb_mix 0.001)
              (set! fxout (rev chan fxout
                               (+ reverb_size (aref mods PARAM_REVERB_SIZE))
                               (+ reverb_predelay (aref mods PARAM_REVERB_PREDELAY))
                               (+ reverb_absorb (aref mods PARAM_REVERB_ABSORB))
                               (+ reverb_mix (aref mods PARAM_REVERB_MIX)))))
          (* gain fxout))))))



